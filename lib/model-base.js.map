{"version":3,"sources":["../src/model-base.js"],"names":["ModelBase","name","knex","plugins","plugin","init","modelName","registry","indexOf","DuplicateModelError","QueryBuilder","Target","foreignKey","Relation","RelationType","ONE_TO_ONE","ONE_TO_MANY","MANY_TO_ONE","props","isNew","value","oldProps","writable","schema","constructor","jsonSchema","ajv","Ajv","validate","ValidationError","errors","qb","getQueryBuilder","UnidentifiedModelError","withRelated","del","changedProps","savablePropNames","whitelistedProps","length","filter","propName","blacklistedProps","oldValue","newValue","undefined","EmptyModelError","update","query","insert"],"mappings":"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","file":"model-base.js","sourcesContent":["import Ajv from 'ajv';\nimport { tableize } from 'inflection';\nimport QueryBuilder from './query-builder';\nimport Relation from './relation';\nimport RelationType from './enums/relation-type';\nimport {\n  DuplicateModelError,\n  EmptyModelError,\n  UnidentifiedModelError,\n  ValidationError,\n} from './errors';\n\n/**\n * Base Model class which should be used as an extension for database entities.\n */\nexport default class ModelBase {\n  /**\n   * Knex client corresponding to the current ORM instance.\n   * @type {Object}\n   * @memberof ModelBase\n   * @static\n   */\n  static knex;\n\n  /**\n   * Plugins to be used for the current ORM instance.\n   * @type {Object[]}\n   * @memberof ModelBase\n   * @static\n   */\n  static plugins = [];\n\n  static registry = [];\n\n  /**\n   * Case-sensitive name of the database table which corresponds to the Model.\n   * @type {string}\n   */\n  static get tableName() { return tableize(this.name); }\n\n  /**\n   * Primary key of the Model, used for instance identification.\n   * @type {string}\n   */\n  static get primaryKey() { return 'id'; }\n\n  /**\n   * List of properties which should exclusively be present in database\n   * entities. If the list is empty, then every enumerable property of the\n   * instance are considered to be database entities.\n   * @type {string[]}\n   */\n  static get whitelistedProps() { return []; }\n\n  /**\n   * List of properties which shall not be present in database entities. The\n   * blacklist takes precedence over any whitelist rule.\n   * @type {string[]}\n   */\n  static get blacklistedProps() { return []; }\n\n  /**\n   * JSON Schema to be used for validating instances of the Model. Validation\n   * happens automatically before executing queries.\n   * @type{?Object}\n   */\n  static get jsonSchema() { return null; }\n\n  /**\n   * Registers this static Model object to the list of database objects.\n   * @param {string} [name] Name under which the Model shall be registered.\n   * @throws {DuplicateModelError}\n   * @returns {Model} The current Model.\n   */\n  static register(name) {\n    // Clone Knex and initialize plugins\n    this.knex = Object.assign({}, this.knex);\n    for (const plugin of this.plugins) {\n      plugin.init(this);\n    }\n\n    // Determine the Model's name and then check if it's already registered\n    const modelName = name || this.name;\n    if (Object.keys(this.registry).indexOf(modelName) >= 0) {\n      throw new DuplicateModelError(modelName);\n    }\n\n    this.registry[modelName] = this;\n    return this;\n  }\n\n  /**\n   * Returns a new QueryBuilder instance which corresponds to the current Model.\n   * @returns {QueryBuilder}\n   */\n  static query() {\n    return new QueryBuilder(this);\n  }\n\n  /**\n   * Creates a one-to-one relation between the current Model and a target.\n   * @param {string|Model} Target Name or static reference to the joinable\n   * table's Model.\n   * @param {string} [foreignKey] Foreign key in the target Model.\n   * @returns {Relation}\n   */\n  static hasOne(Target, foreignKey) {\n    return new Relation(this, Target, RelationType.ONE_TO_ONE, foreignKey);\n  }\n\n  /**\n   * Creates a one-to-many relation between the current Model and a target.\n   * @param {string|Model} Target Name or static reference to the joinable\n   * table's Model.\n   * @param {string} [foreignKey] Foreign key in the target Model.\n   * @returns {Relation}\n   */\n  static hasMany(Target, foreignKey) {\n    return new Relation(this, Target, RelationType.ONE_TO_MANY, foreignKey);\n  }\n\n  /**\n   * Creates a many-to-one relation between the current Model and a target.\n   * @param {string|Model} Target Name or static reference to the joinable\n   * table's Model.\n   * @param {string} [foreignKey] Foreign key in this Model.\n   * @returns {Relation}\n   */\n  static belongsTo(Target, foreignKey) {\n    return new Relation(this, Target, RelationType.MANY_TO_ONE, foreignKey);\n  }\n\n  /**\n   * Creates a new Model instance.\n   * @param {Object} [props={}] Initial properties of the instance.\n   * @param {boolean} [isNew=true] True if the instance is not yet stored\n   * persistently in the database.\n   */\n  constructor(props = {}, isNew = true) {\n    // Set the initial properties of the instance\n    Object.assign(this, props);\n\n    // Initialize a store for old properties of the instance\n    Object.defineProperties(this, {\n      isNew: {\n        value: isNew,\n      },\n      oldProps: {\n        value: isNew ? {} : Object.assign({}, props),\n        writable: true,\n      },\n    });\n  }\n\n  /**\n   * Validates all the enumerable properties of the current instance.\n   * @throws {ValidationError}\n   */\n  validate() {\n    const schema = this.constructor.jsonSchema;\n    if (!schema) return; // The Model is valid if no schema is given\n\n    const ajv = new Ajv();\n    if (!ajv.validate(schema, this)) {\n      throw new ValidationError(ajv.errors);\n    }\n  }\n\n  /**\n   * Queues fetching the given related Models of the current instance.\n   * @param {...string} props Relation attributes to be fetched.\n   * @returns {QueryBuilder}\n   */\n  fetchRelated(...props) {\n    const qb = this.getQueryBuilder();\n    if (!qb) throw new UnidentifiedModelError();\n\n    return qb.withRelated(...props);\n  }\n\n  /**\n   * Queues the deletion of the current Model from the database.\n   * @throws {UnidentifiedModelError}\n   * @returns {QueryBuilder}\n   */\n  del() {\n    const qb = this.getQueryBuilder();\n    if (!qb) throw new UnidentifiedModelError();\n\n    return qb.del();\n  }\n\n  /**\n   * Queues saving (creating or updating) the current Model in the database.\n   * @throws {EmptyModelError}\n   * @returns {QueryBuilder}\n   */\n  save() {\n    const qb = this.getQueryBuilder();\n    const changedProps = {};\n\n    // By default, save only the whitelisted properties, but if none is present,\n    // then save every property. Use the blacklist for filtering the results.\n    const savablePropNames = (\n      this.constructor.whitelistedProps.length > 0 ?\n      this.constructor.whitelistedProps :\n      Object.keys(this)\n    ).filter((propName) =>\n      this.constructor.blacklistedProps.indexOf(propName) < 0\n    );\n\n    for (const propName of savablePropNames) {\n      const oldValue = this.oldProps[propName];\n      const newValue = this[propName];\n\n      // New and modified properties must be updated\n      if (oldValue === undefined || newValue !== oldValue) {\n        changedProps[propName] = newValue;\n      }\n    }\n\n    // Don't run unnecessary queries\n    if (Object.keys(changedProps).length === 0) {\n      if (!qb) throw new EmptyModelError();\n\n      return qb;\n    }\n\n    // Update the Model's old properties with the new ones\n    Object.assign(this.oldProps, changedProps);\n\n    // Insert or update the current instance in the database\n    return qb ?\n      qb.update(changedProps) :\n      this.constructor.query().insert(changedProps);\n  }\n\n  /**\n   * @returns {?QueryBuilder}\n   * @private\n   */\n  getQueryBuilder() {\n    if (this.isNew) return null;\n\n    return new QueryBuilder(this.constructor, this);\n  }\n}\n"]}