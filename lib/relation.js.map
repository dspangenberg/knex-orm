{"version":3,"sources":["../src/relation.js"],"names":["Relation","Origin","Target","type","foreignKey","modelRegistry","registry","Interim","otherKey","originInstances","OriginAttribute","TargetAttribute","query","whereIn","length","map","model","models","createQuery","then","relatedModels","relatedModel","foreignValue","originInstance","find","name","undefined","RelationType","ONE_TO_MANY","push","RelationError","isTypeFromOne","primaryKey","MANY_TO_ONE","MANY_TO_MANY","indexOf"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AACA;;;;AACA;;AACA;;;;AAEA;;;;IAIqBA,Q;;AAiBnB;;;;;;;AAhBA;;;;;;AAgCA,oBAAYC,MAAZ,EAAoBC,MAApB,EAA4BC,IAA5B,EAAkCC,UAAlC,EAA8C;AAAA;;AAC5C,SAAKH,MAAL,GAAcA,MAAd;;AAEA;AACA,QAAMI,gBAAgBJ,OAAOK,QAA7B;AACA,SAAKJ,MAAL,GAAc,OAAOA,MAAP,KAAkB,QAAlB,GAA6BG,cAAcH,MAAd,CAA7B,GAAqDA,MAAnE;;AAEA,SAAKC,IAAL,GAAYA,IAAZ;AACA,QAAIC,UAAJ,EAAgB,KAAKA,UAAL,GAAkBA,UAAlB;AACjB;;AAED;;;;;;;AAnBA;;;;;;;;AAhBA;;;;;;;;;;;;AAkEA;;;;;;;4BAOQG,O,EAASH,U,EAAYI,Q,EAAU;AAAE;AACvC;AACA,aAAO,IAAP;AACD;;AAED;;;;;;;;gCAKYC,e,EAAiB;AAAA,UACnBC,eADmB,GACkB,IADlB,CACnBA,eADmB;AAAA,UACFC,eADE,GACkB,IADlB,CACFA,eADE;;;AAG3B,aAAO,KAAKT,MAAL,CAAYU,KAAZ,GACJC,OADI,CAEHH,eAFG,EAGHD,gBAAgBK,MAAhB,GAAyB,CAAzB,GAA6B;AAC3BL,sBAAgBM,GAAhB,CAAoB,UAACC,KAAD;AAAA,eAAWA,MAAML,eAAN,CAAX;AAAA,OAApB,CADF,GAEE,qBAAmBA,eAAnB,CALC,CAAP;AAOD;;AAED;;;;;;;;;iCAM+B;AAAA;;AAAA,wCAAjBF,eAAiB;AAAjBA,uBAAiB;AAAA;;AAC7B,UAAMQ,SAAS,yBAAaR,eAAb,CAAf;AAD6B,UAErBC,eAFqB,GAEgB,IAFhB,CAErBA,eAFqB;AAAA,UAEJC,eAFI,GAEgB,IAFhB,CAEJA,eAFI;;AAI7B;;AACA,aAAO,KAAKO,WAAL,CAAiBD,MAAjB,EACJE,IADI,CACC,UAACC,aAAD,EAAmB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,gBACZC,YADY;;AAErB;AACA,gBAAMC,eAAeD,aAAaX,eAAb,CAArB;AACA,gBAAMa,iBAAiBN,OAAOO,IAAP,CAAY,UAACR,KAAD;AAAA,qBACjCA,MAAML,eAAN,MAA2BW,YADM;AAAA,aAAZ,CAAvB;;AAIA,gBAAIC,cAAJ,EAAoB;AAClB,kBAAIA,eAAe,MAAKE,IAApB,MAA8BC,SAAlC,EAA6C;AAC3C;AACA,oBAAI,MAAKvB,IAAL,KAAcwB,uBAAaC,WAA/B,EAA4C;AAC1CL,iCAAe,MAAKE,IAApB,IAA4B,CAACJ,YAAD,CAA5B;AACD,iBAFD,MAEO;AACLE,iCAAe,MAAKE,IAApB,IAA4BJ,YAA5B;AACD;AACF,eAPD,MAOO;AACL;AACA,oBAAI,MAAKlB,IAAL,KAAcwB,uBAAaC,WAA/B,EAA4C;AAC1CL,iCAAe,MAAKE,IAApB,EAA0BI,IAA1B,CAA+BR,YAA/B;AACD,iBAFD,MAEO;AACL,wBAAM,IAAIS,qBAAJ,EAAN;AACD;AACF;AACF;AAxBoB;;AACvB,0DAA2BV,aAA3B,4GAA0C;AAAA;AAwBzC;AAzBsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BxB,OA3BI,CAAP;AA4BD;;;wBA9FgB;AACf;AACA,aAAO,KAAKW,aAAL,GACF,4BAAW,KAAK9B,MAAL,CAAYwB,IAAvB,CADE,WAEF,4BAAW,KAAKvB,MAAL,CAAYuB,IAAvB,CAFE,QAAP;AAGD;;;wBAEqB;AACpB,aAAO,KAAKM,aAAL,GACL,KAAK3B,UADA,GAEL,KAAKF,MAAL,CAAY8B,UAFd;AAGD;;;wBAEqB;AACpB,aAAO,KAAKD,aAAL,GACL,KAAK9B,MAAL,CAAY+B,UADP,GAEL,KAAK5B,UAFP;AAGD;;;wBAEmB;AAClB,aAAO,CACLuB,uBAAaM,WADR,EAELN,uBAAaO,YAFR,EAGLC,OAHK,CAGG,KAAKhC,IAHR,IAGgB,CAHvB;AAID;;;;;kBAzEkBH,Q","file":"relation.js","sourcesContent":["import { underscore } from 'inflection';\nimport RelationType from './enums/relation-type';\nimport { RelationError } from './errors';\nimport { flattenArray } from './utils';\n\n/**\n * Represents a relation between Models.\n * @private\n */\nexport default class Relation {\n  /**\n   * Static Model object which shall be joined with the target.\n   * @type {Model}\n   * @memberof Relation\n   * @instance\n   */\n  Origin;\n\n  /**\n   * Static Model object which corresponds to the origin.\n   * @type {Model}\n   * @memberof Relation\n   * @instance\n   */\n  Target;\n\n  /**\n   * Type of the relation between Origin and Target.\n   * @type {RelationType}\n   * @memberof Relation\n   * @instance\n   */\n  type;\n\n  /**\n   * Name of the Relation.\n   * @type {string}\n   * @memberof Relation\n   * @instance\n   */\n  name;\n\n  constructor(Origin, Target, type, foreignKey) {\n    this.Origin = Origin;\n\n    // Get the target's registered Model if target is a string\n    const modelRegistry = Origin.registry;\n    this.Target = typeof Target === 'string' ? modelRegistry[Target] : Target;\n\n    this.type = type;\n    if (foreignKey) this.foreignKey = foreignKey;\n  }\n\n  /**\n   * The attribute which points to the primary key of the joinable database\n   * table.\n   * @type {string}\n   */\n  get foreignKey() {\n    // Set the foreign key deterministically\n    return this.isTypeFromOne ?\n      `${underscore(this.Origin.name)}_id` :\n      `${underscore(this.Target.name)}_id`;\n  }\n\n  get OriginAttribute() {\n    return this.isTypeFromOne ?\n      this.foreignKey :\n      this.Target.primaryKey;\n  }\n\n  get TargetAttribute() {\n    return this.isTypeFromOne ?\n      this.Origin.primaryKey :\n      this.foreignKey;\n  }\n\n  get isTypeFromOne() {\n    return [\n      RelationType.MANY_TO_ONE,\n      RelationType.MANY_TO_MANY,\n    ].indexOf(this.type) < 0;\n  }\n\n  /**\n   * Creates a many-to-many Relation from a one-to many Relation.\n   * @param {string|Model} Interim Name or static reference to the pivot Model.\n   * @param {string} [foreignKey] Foreign key in this Model.\n   * @param {string} [otherKey] Foreign key in the Interim Model.\n   * @returns {Relation}\n   */\n  through(Interim, foreignKey, otherKey) { // eslint-disable-line\n    // TODO\n    return this;\n  }\n\n  /**\n   * Creates a query based on the given origin Model instances.\n   * @param {Object[]} originInstances Origin Model instances.\n   * @returns {QueryBuilder}\n   */\n  createQuery(originInstances) {\n    const { OriginAttribute, TargetAttribute } = this;\n\n    return this.Target.query()\n      .whereIn(\n        OriginAttribute,\n        originInstances.length > 0 ? // Pass a mock value if necessary\n          originInstances.map((model) => model[TargetAttribute]) :\n          [`originInstance.${TargetAttribute}`]\n      );\n  }\n\n  /**\n   * Applies the relation by executing subqueries on the origin Model instances.\n   * @param {...Object} originInstances Origin Model instances.\n   * @throws {RelationError}\n   * @returns {Promise}\n   */\n  applyAsync(...originInstances) {\n    const models = flattenArray(originInstances);\n    const { OriginAttribute, TargetAttribute } = this;\n\n    // Create and then execute the query, handling Model bindings\n    return this.createQuery(models)\n      .then((relatedModels) => {\n        for (const relatedModel of relatedModels) {\n          // Pair up the related Model with its origin\n          const foreignValue = relatedModel[OriginAttribute];\n          const originInstance = models.find((model) =>\n            model[TargetAttribute] === foreignValue\n          );\n\n          if (originInstance) {\n            if (originInstance[this.name] === undefined) {\n              // Initially set the origin's related property\n              if (this.type === RelationType.ONE_TO_MANY) {\n                originInstance[this.name] = [relatedModel];\n              } else {\n                originInstance[this.name] = relatedModel;\n              }\n            } else {\n              // Modify the origin instance's related property if possible\n              if (this.type === RelationType.ONE_TO_MANY) {\n                originInstance[this.name].push(relatedModel);\n              } else {\n                throw new RelationError();\n              }\n            }\n          }\n        }\n      });\n  }\n}\n"]}